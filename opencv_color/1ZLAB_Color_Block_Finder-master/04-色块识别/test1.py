# -*- coding:utf-8 -*-
import cv2 as cv
# Argparse的作用就是为py文件封装好可以选择的参数，使他们更加灵活，丰富。
import argparse
# sys模块包含了与Python解释器和它的环境有关的函数。
import sys
# NumPy系统是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵
import numpy as np
# 通过os模块调用系统命令
import os
# 调用随机的方法
import random
import time
import signal, subprocess 

def forInImg():
    # 遍历图片
    rootPath = "/home/siiva/MOME/scripts/sava_img_files"
    for dirpath, dirnames, filenames in os.walk(rootPath):
        if(len(filenames) == 0):
            global timesT
            timesT = timesT - 1
            print(timesT)
            time.sleep(0.2)
            if(timesT > 0):
                forInImg()
            else:
                sys.exit(1)
        else:
            timesT = 10
            for filepath in filenames:
                # 打开图像文件
                Img = cv.VideoCapture(os.path.join(dirpath, filepath))
                # 从图片中得到Frame
                global frame
                hasFrame, frame = Img.read()

                kernel_2 = np.ones((2,2),np.uint8)#2x2的卷积核
                kernel_3 = np.ones((3,3),np.uint8)#3x3的卷积核
                kernel_4 = np.ones((4,4),np.uint8)#4x4的卷积核
                HSV = cv.cvtColor(Img, cv.COLOR_BGR2HSV)#把BGR图像转换为HSV格式
                '''
                HSV模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）
                下面两个值是要识别的颜色范围
                '''
                Lower = np.array([96, 210, 85])#要识别颜色的下限
                Upper = np.array([114, 255, 231])#要识别的颜色的上限
                #mask是把HSV图片中在颜色范围内的区域变成白色，其他区域变成黑色
                mask = cv.inRange(HSV, Lower, Upper)
                #下面四行是用卷积进行滤波
                erosion = cv.erode(mask,kernel_4,iterations = 1)
                erosion = cv.erode(erosion,kernel_4,iterations = 1)
                dilation = cv.dilate(erosion,kernel_4,iterations = 1)
                dilation = cv.dilate(dilation,kernel_4,iterations = 1)
                #target是把原图中的非目标颜色区域去掉剩下的图像
                target = cv.bitwise_and(Img, Img, mask=dilation)
                #将滤波后的图像变成二值图像放在binary中
                ret, binary = cv.threshold(dilation,127,255,cv.THRESH_BINARY) 
                #在binary中发现轮廓，轮廓按照面积从小到大排列
                contours, hierarchy = cv.findContours(binary,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE) 
                p=0
                for i in contours:#遍历所有的轮廓
                    x,y,w,h = cv.boundingRect(i)#将轮廓分解为识别对象的左上角坐标和宽、高
                    #在图像上画上矩形（图片、左上角坐标、右下角坐标、颜色、线条宽度）
                    cv.rectangle(Img,(x,y),(x+w,y+h),(0,255,),3)
                    #给识别对象写上标号
                    font=cv2.FONT_HERSHEY_SIMPLEX
                    cv.putText(Img,str(p),(x-10,y+10), font, 1,(0,0,255),2)#加减10是调整字符位置
                    p +=1
                print(p)#终端输出目标数量
                cv.imshow('target2', target)
                cv.imshow('Mask1', mask)
                cv.imshow("dilation3", dilation)
                cv.imshow('Img', Img)
                cv.imwrite('Img.png', Img)#将画上矩形的图形保存到当前目录  

                # 删除多余文件
                # os.remove(os.path.join(dirpath, filepath))

                # cv.imshow(winName, frame)
                cv.waitKey(1000)

# while(True):
forInImg()
